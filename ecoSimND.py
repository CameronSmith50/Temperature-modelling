# A class which will take in parameters generated by initDim from
# initialisation.py and will be able to run ecological simulations, plot the
# results and conduct any other relevant processes.

# Import packages
import numpy as np
import matplotlib.pyplot as plt
import Lookup as LU
from Initialisation import initNonDim
import json
import os
import sys

#%% Class definition

class nondimensionalSim(object):
    '''
    A class which will contain all simulation and plotting tools for anything
    associated with a simulation
    '''

    def __init__(self, pars, saveRes = False):
        '''
        Initialisation. pars should be a dictionary generated by initNonDim().
        saveRes checks if a simulation and its plot should be saved
        '''

        self.pars = pars
        self.r = pars['growthRatio'] # Ratio of growth rates
        self.phiW = pars['fecunW'] # Fecundity loss of W
        self.phiM = pars['fecunM'] # Fecundity loss of M
        self.d = pars['natMortND'] # Natural mortality
        self.alphaW = pars['virNDW'] # Virulence of W
        self.alphaM = pars['virNDM']  # Virulence of M
        self.a = pars['pathShedND']  # Shedding of pathogen on plate
        self.eta = pars['pathLossND']  # Reduction of pathogen on transmisison
        self.gamma = pars['pathDilND'] # Dilution effects
        self.delta = pars['pathDecayND']  # Decay of pathogen
        self.rho = pars['pathGrowND'] # Initrinsic growth rate of pathogen
        self.K = pars['pathCapND'] # "Carrying capacity" of pathogen
        self.saveRes = saveRes  # Do we save the simulation?

        # Initialise the state and times
        self.state0 = np.array([0.5, 0.0, 0.5, 0.0, self.K])
        self.tFinal = pars['tEco']


    def RHSFunction(self, t, state):
        '''
        RHS functions for the ODEs
        '''

        # Total population size
        n = np.sum(state[:-1])

        # ODE for susceptible wildtype
        SW = (state[0] + (1-self.phiW)*state[1])*(1-n) - state[0]*state[4] - \
                self.d*state[0]

        # ODE for infected wildtype
        IW = state[0]*state[4] - self.alphaW*state[1] - self.d*state[1]

        # ODE for susceptible mutant
        SM = self.r*(state[2] + (1-self.phiM)*state[3])*(1-n) - \
                state[2]*state[4] - self.d*state[2]

        # ODE for infected mutant
        IM = state[2]*state[4] - self.alphaM*state[3] - self.d*state[3]

        # ODE for pathogen
        P = self.rho*state[4]*(1-state[4]/self.K) - self.delta*state[4] + \
                self.a*(state[1]+state[3]) - (self.eta*(state[0] + \
                state[2]) + self.gamma*(state[2]+state[3]))*state[4]
        
        # Return
        return(np.array([SW, IW, SM, IM, P]))
    
    def rk45update(self, t, state, dt, tol = 1e-3):
        """
        RK45 update using RHSFunction over a time-step dt.
        Code will calculate new time steps adaptively.
        """

        # RK scheme
        A = [0, 2/9, 1/3, 3/4, 1, 5/6]
        B = [[], [2/9], [1/12, 1/4], [69/128, -243/128, 135/64], \
                [-17/12, 27/4, -27/5, 16/15], [65/432, -5/16, 13/16, 4/27, \
                5/144]]
        C = [1/9, 0, 9/20, 16/45, 1/12]
        CH = [47/450, 0, 12/25, 32/225, 1/30, 6/25]
        CT = [1/150, 0, -3/100, 16/75, 1/20, -6/25]

        # We haven't yet done the step
        doneStep = False

        # While loop
        while not doneStep:

            # RK45 k values
            k1 = dt*self.RHSFunction(t + A[0]*dt, state)
            k2 = dt*self.RHSFunction(t + A[1]*dt, state + B[1][0]*k1)
            k3 = dt*self.RHSFunction(t + A[2]*dt, state + B[2][0]*k1 + \
                    B[2][1]*k2)
            k4 = dt*self.RHSFunction(t + A[3]*dt, state + B[3][0]*k1 + \
                    B[3][1]*k2 + B[3][2]*k3)
            k5 = dt*self.RHSFunction(t + A[4]*dt, state + B[4][0]*k1 + \
                    B[4][1]*k2 + B[4][2]*k3 + B[4][3]*k4)
            k6 = dt*self.RHSFunction(t + A[5]*dt, state + B[5][0]*k1 + \
                    B[5][1]*k2 + B[5][2]*k3 + B[5][3]*k4 + B[5][4]*k5)

            # Calculate truncation error
            TE = np.linalg.norm(CT[0]*k1 + CT[1]*k2 + CT[2]*k3 + CT[3]*k4 + \
                        CT[4]*k5 + CT[5]*k6)

            # New time-step
            dtNew = 0.9*dt*(tol/TE)**0.2

            # Check if we accept
            if TE <= tol:
                doneStep = True
            else:
                dt = dtNew

        # Return the new timestep and state
        return(dtNew, state + CH[0]*k1 + CH[1]*k2 + CH[2]*k3 + CH[3]*k4 + \
                CH[4]*k5 + CH[5]*k6)
    
    def solveSystem(self):
        '''
        Solves the system using the ODE defined in RHSFunction and the rk45
        solver from an initial state state0 up to finalTime.
        State0 should be a list
        '''
        
        # Initialise
        dt = 0.01
        t = 0.0
        state = self.state0
        self.store = [state]
        self.times = [t]
        
        # Run the RK45 solver
        while t < self.tFinal:
            [dt, state] = self.rk45update(t, state, dt)
            t += dt
            self.store.append(state)
            self.times.append(t)

        self.store = np.array(self.store)
        self.SS = self.store[-1]

    def plot(self):
        '''
        Plotting code for a simulation
        '''

        # Check if simulated
        try:
            self.store
        except:
            print('Not yet simulated')

        # Create the figure
        figWidth = 10
        figHeight = 15
        fig = plt.figure(figsize=(figWidth, figHeight))
        ax1 = fig.add_subplot(311)
        ax2 = fig.add_subplot(312)
        ax3 = fig.add_subplot(313)

        # Create vectors for the proportions of each genotype over time
        self.storeMat = np.array(self.store)
        self.NVec = np.sum(self.storeMat[:, :-1], axis=1)
        self.XW = np.sum(self.storeMat[:,:2], axis=1)/self.NVec
        self.XM = np.sum(self.storeMat[:,2:4], axis=1)/self.NVec

        # Plotting of the numbers of SW, SM, IW, IM
        ax1.plot(self.times, self.storeMat[:, 0], 'b--', lw=2, label = 'N2-sus')
        ax1.plot(self.times, self.storeMat[:, 1], 'b', lw=2, label = 'N2-inf')
        ax1.plot(self.times, self.storeMat[:, 2], 'r--', lw=2, 
                label = 'srf-2-sus')
        ax1.plot(self.times, self.storeMat[:, 3], 'r', lw=2, 
                label = 'srf-2-inf')
        ax1.plot(self.times, np.sum(self.storeMat[:,:4], axis=1), 'k--', lw=2)
        ax1.legend()

        # Proportions of each type
        ax2.plot(self.times, self.XW, 'b', lw=2, label = 'N2')
        ax2.plot(self.times, self.XM, 'r', lw=2, label = 'srf-2')
        ax2.set_ylim([0, 1])

        # Pathogen density
        ax3.plot(self.times, self.storeMat[:, 4], 'k', lw=2)

        if self.saveRes:
            self.saveName = self.save()
            fig.savefig(f'./Figures/{self.saveName}/nondimEcoSim.png',
                         bbox_inches='tight')
            fig.savefig(f'./Figures/{self.saveName}/nondimEcoSim.pdf',
                         bbox_inches='tight')
        else:
            plt.show()


    def save(self):
        '''
        Adds in saving functionality. Should be created when the figures are
        plotted. 
        '''

        # Generate a save name, and append ECO to it
        saveName = LU.createSaveName(prefix = 'NON-DIM')

        # Add an entry to the lookup table
        LU.addEntrytoLookup(saveName, self.pars, 'NON-DIM')

        # Create the appropriate directories
        dataDir = f'./Data/{saveName}/'
        figDir = f'./Figures/{saveName}/'
        os.makedirs(dataDir)
        os.makedirs(figDir)

        # Save a text file with the parameter values, as well as a json file
        # containing the solution matrix and time vector
        with open(dataDir + 'parameters.txt', 'w') as file:
            file.write('Parameters:\n')
            file.write('----------\n')
            file.write('\n')
            for key, val in self.pars.items():
                file.write(f'{key: <13}: {val:.3f}\n')
        with open(dataDir + 'ecoSim.json', 'w') as file:
            json.dump(['Time vector', self.times, 'Solution matrix', \
                       self.store.tolist()], file)

        return(saveName)
    
#%% Code to execute

if __name__ == '__main__':

    # Initialise simulation
    pars = initNonDim()

    # If we just want to plot without saving, type python ecoSimulation.py into
    # the command window
    if len(sys.argv) < 2:
        sim = nondimensionalSim(pars)
        sim.solveSystem()
        sim.plot()

    # If we want to save, type python ecoSimulation.py save into the command
    # window 
    elif sys.argv[1] == 'save':
        sim = nondimensionalSim(pars, saveRes = True)
        sim.solveSystem()
        sim.plot()